{
  "entities": {
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents a material order placed by a construction company.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the order."
        },
        "applicantName": {
          "type": "string",
          "description": "Name of the person requesting the order."
        },
        "projectName": {
          "type": "string",
          "description": "Name of the construction project."
        },
        "location": {
          "type": "string",
          "description": "Location of the construction project."
        },
        "minDeliveryDate": {
          "type": "string",
          "description": "Earliest possible delivery date for the order.",
          "format": "date-time"
        },
        "maxDeliveryDate": {
          "type": "string",
          "description": "Latest possible delivery date for the order.",
          "format": "date-time"
        },
        "paymentType": {
          "type": "string",
          "description": "Type of payment for the order (Cash or Credit).",
          "format": "enum",
          "items": {
            "type": "string"
          }
        },
        "creditInstallmentType": {
          "type": "string",
          "description": "Type of credit installment (Weekly, Bi-weekly, Monthly). Only applicable if paymentType is Credit.",
          "format": "enum",
          "items": {
            "type": "string"
          }
        },
        "paymentMethod": {
          "type": "string",
          "description": "Payment method used for the order (e.g., credit card). Only applicable if paymentType is Credit."
        },
        "orderStatus": {
          "type": "string",
          "description": "The status of the order"
        }
      },
      "required": [
        "id",
        "applicantName",
        "projectName",
        "location",
        "minDeliveryDate",
        "maxDeliveryDate",
        "paymentType"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous",
      "google.com"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/orders/{orderId}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Stores all order documents. The orderId is a unique identifier for each order.",
          "params": [
            {
              "name": "orderId",
              "description": "Unique identifier for the order document."
            }
          ]
        }
      }
    ],
    "reasoning": "Given the requirements for a user-friendly order management system for a construction company, with features like order registration, real-time display, filtering, and temporary data persistence, the following Firestore structure is recommended. It prioritizes simplicity and scalability for the initial frontend-only implementation, while also preparing for future authentication and more complex security rules. The structure avoids authorization dependencies to allow atomic operations.\n\nThe proposed structure includes a single collection: `orders`. This collection will store all order documents. Since this is a front-end only application with temporary persistence, and the instructions mention preparing for future authentication, there are no user-specific subcollections or complex access control mechanisms yet. This simplifies the initial data model.\n\nSince all orders share the same security posture (for now), a single `orders` collection satisfies Structural Segregation. As authentication gets implemented, role-based access control can be handled in the security rules of this collection by checking if the user has a specific role (e.g., admin) that allows them to view or modify all orders. For example, a hypothetical `roles_admin` collection could be used in Firestore rules to grant admin privileges based on a user's UID existing in that collection. Such collection would enable QAPs with secure `list` operations via existence check.\n"
  }
}