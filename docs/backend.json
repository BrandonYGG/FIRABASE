{
  "entities": {
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents a material order placed by a construction company.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the order."
        },
        "applicantName": {
          "type": "string",
          "description": "Name of the person requesting the order."
        },
        "projectName": {
          "type": "string",
          "description": "Name of the construction project."
        },
        "location": {
          "type": "string",
          "description": "Location of the construction project. Supports autocompletion."
        },
        "minDeliveryDate": {
          "type": "string",
          "description": "The earliest acceptable delivery date.",
          "format": "date-time"
        },
        "maxDeliveryDate": {
          "type": "string",
          "description": "The latest acceptable delivery date.",
          "format": "date-time"
        },
        "paymentType": {
          "type": "string",
          "description": "Type of payment for the order (Credit or Cash)."
        },
        "creditInstallmentType": {
          "type": "string",
          "description": "Type of credit installments (Weekly, Bi-Weekly, Monthly). Only applicable if payment type is credit.",
          "format": "string"
        },
        "paymentMethod": {
          "type": "string",
          "description": "The selected payment method."
        },
        "urgencyLevel": {
          "type": "string",
          "description": "The urgency level of the order (Normal, Soon, Urgent). Derived from delivery dates."
        },
        "deliveryStatus": {
          "type": "string",
          "description": "The delivery status of the order."
        }
      },
      "required": [
        "id",
        "applicantName",
        "projectName",
        "location",
        "minDeliveryDate",
        "maxDeliveryDate",
        "paymentType"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/orders/{orderId}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Stores material orders placed by construction companies. The initial implementation allows for temporal persistence without user authentication. 'orderId' is the unique identifier for each order.",
          "params": [
            {
              "name": "orderId",
              "description": "Unique identifier for the order."
            }
          ]
        }
      }
    ],
    "reasoning": "Given the requirement for a purely frontend application interacting directly with Firestore, a flat collection structure is suitable for initial temporal persistence. As the application evolves, especially with the introduction of user authentication, the structure should be adjusted to incorporate user-specific subcollections for better security and scalability. For now, the focus remains on enabling the core features of order registration, display, filtering, and urgency indication, all while storing data temporarily.\n\nThe design uses structural segregation by placing all orders in a single collection. This simplifies the initial security rules setup as all documents within the 'orders' collection share the same security posture during the initial phase. This approach supports the required QAPs by enabling simple list operations.\n\nThe authorization independence principle is not fully applied in this initial setup because there is no user authentication. However, future iterations should incorporate denormalization strategies as the application gains complexity, especially when user roles and access controls become relevant. This would typically involve denormalizing user roles or permissions into the order documents themselves to avoid complex `get()` calls in security rules."
  }
}